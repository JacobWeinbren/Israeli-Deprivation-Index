<div id="map" class="w-screen h-screen"></div>
<div id="geocoder" class="geocoder fixed top-4 left-4 z-10"></div>
<div
	class="sm:w-[500px] text-sm w-full flex flex-col gap-2 absolute bottom-10 rounded-md z-10 bg-white p-4 left-1/2 transform -translate-x-1/2"
>
	<div>
		<p class="text-md font-semibold" id="title">
			Socio-Economic Classification
		</p>
		<p class="mb-2">Israel (inc West Bank)</p>
	</div>
	<div>
		<div class="w-full h-4 rounded" id="gradient"></div>
		<div class="flex justify-between">
			<span id="min">Least Affluent (1)</span>
			<span id="max">Most Affluent (10)</span>
		</div>
	</div>
	<div id="hover">Hover over a point to see its value.</div>
</div>

<script>
	import { GeoJsonLayer } from "@deck.gl/layers";
	import { MapboxOverlay } from "@deck.gl/mapbox";
	import { MVTLayer } from "@deck.gl/geo-layers";
	import { MaskExtension } from "@deck.gl/extensions";
	import MapboxGeocoder from "@mapbox/mapbox-gl-geocoder";
	import mapboxgl from "mapbox-gl";
	import chroma from "chroma-js";

	const MAPBOX_TOKEN = import.meta.env.PUBLIC_MAPBOX_TOKEN;

	const colorScale = chroma
		.scale(["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"])
		.domain([0, 10]);

	const map = new mapboxgl.Map({
		container: "map",
		style: "mapbox://styles/mapbox/dark-v11",
		center: [35.2345, 31.7767],
		minZoom: 6,
		maxZoom: 17,
		zoom: 9,
		accessToken: MAPBOX_TOKEN,
		antialias: true,
		projection: { name: "mercator" },
	});

	const deckOverlay = new MapboxOverlay({
		interleaved: true,
		layers: [],
	});

	map.addControl(deckOverlay);

	function createBackgroundLayer() {
		return new MVTLayer({
			id: "background-layer",
			data: "https://map.jacobweinbren.workers.dev/israel-deprivation-areas/{z}/{x}/{y}.mvt",
			getFillColor: () => [0, 0, 0, 0],
			pickable: true,
			onHover: (info) => {
				const infoDiv = document.querySelector("#hover");
				if (info.object) {
					const feature = info.object;
					const clusterValue = feature.properties.CLUSTER.toFixed(0);
					const ordinal = (n) => {
						const s = ["th", "st", "nd", "rd"];
						const v = n % 100;
						return n + (s[(v - 20) % 10] || s[v] || s[0]);
					};
					const hoverText =
						clusterValue >= 5
							? `This area is in cluster ${clusterValue} of 10, making it the ${ordinal(
									11 - clusterValue
								)} least deprived.`
							: `This area is in cluster ${clusterValue} of 10, making it the ${ordinal(
									clusterValue
								)} most deprived.`;
					infoDiv.innerHTML = hoverText;
				} else {
					infoDiv.innerHTML = "Hover over a point to see its value.";
				}
			},
		});
	}

	map.on("load", () => {
	const firstLabelLayerId = map
		.getStyle()
		.layers.find((layer) => layer.type === "symbol").id;

	function createMaskLayer() {
		return new MVTLayer({
			id: "mask-layer",
			data: "https://map.jacobweinbren.workers.dev/israel-cleaned/{z}/{x}/{y}.mvt",
			binary: false,
			operation: "mask",
			getFillColor: [255, 255, 255],
			lineWidthMinPixels: 1,
			beforeId: firstLabelLayerId,
		});
	}

	function createForegroundLayer() {
		return new MVTLayer({
			id: "foreground-layer",
			data: "https://map.jacobweinbren.workers.dev/israel-deprivation-areas/{z}/{x}/{y}.mvt",
			getFillColor: (d) => {
				const value = d.properties.CLUSTER;
				if (value === null) return [0, 0, 0, 0];
				const color = colorScale(value).rgb();
				return [...color, 255];
			},
			updateTriggers: {
				getFillColor: [],
			},
			extensions: [new MaskExtension()],
			maskId: "mask-layer",
			beforeId: firstLabelLayerId,
		});
	}

	function updateMap() {
		const maskLayer = createMaskLayer();
		const backgroundLayer = createBackgroundLayer();
		const foregroundLayer = createForegroundLayer();

		deckOverlay.setProps({
			layers: [maskLayer, backgroundLayer, foregroundLayer],
		});
	}

	updateMap();

	const geocoder = new MapboxGeocoder({
		accessToken: MAPBOX_TOKEN,
		mapboxgl: mapboxgl,
		marker: false,
	});

	document.getElementById("geocoder").appendChild(geocoder.onAdd(map));
});


	const gradient = document.getElementById("gradient");
	const gradientStyle = `linear-gradient(to right, ${colorScale
		.colors(5)
		.map((color) => color)
		.join(", ")})`;
	gradient.style.background = gradientStyle;


</script>